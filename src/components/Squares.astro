---
export interface Props {
  direction?: "diagonal" | "up" | "right" | "down" | "left";
  speed?: number;
  borderColor?: string;
  squareSize?: number;
  hoverFillColor?: string;
  maxHeight?: number;
}

const {
  direction = "right",
  speed = 1,
  borderColor = "#999",
  squareSize = 40,
  hoverFillColor = "#222",
  maxHeight,
} = Astro.props;

const maxHeightCSS = maxHeight ? `${maxHeight}px` : '100%';
---

<canvas 
  id="squares-canvas" 
  class="squares-canvas"
  data-direction={direction}
  data-speed={speed}
  data-border-color={borderColor}
  data-square-size={squareSize}
  data-hover-fill-color={hoverFillColor}
  data-max-height={maxHeight}
></canvas>

<style define:vars={{ maxHeightCSS }}>
  .squares-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: var(--maxHeightCSS, 100%);
    max-height: var(--maxHeightCSS, 100%);
    border: none;
    display: block;
    z-index: -1;
    pointer-events: none;
    overflow: hidden;
  }
</style>

<script>
  class SquaresBackground {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = this.canvas.getContext('2d');
      this.requestRef = null;
      this.numSquaresX = 0;
      this.numSquaresY = 0;
      this.gridOffset = { x: 0, y: 0 };
      this.hoveredSquare = null;
      
      // Read config from data attributes
      this.direction = this.canvas.dataset.direction || 'right';
      this.speed = parseFloat(this.canvas.dataset.speed || '1');
      this.borderColor = this.canvas.dataset.borderColor || '#999';
      this.squareSize = parseFloat(this.canvas.dataset.squareSize || '40');
      this.hoverFillColor = this.canvas.dataset.hoverFillColor || '#222';
      const maxHeightStr = this.canvas.dataset.maxHeight;
      this.maxHeight = maxHeightStr ? parseFloat(maxHeightStr) : undefined;

      this.init();
    }
    
    init() {
      this.resizeCanvas();
      this.resizeHandler = () => this.resizeCanvas();
      window.addEventListener('resize', this.resizeHandler);
      this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
      this.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());
      this.animate();
    }
    
    resizeCanvas() {
      if (!this.canvas) return;
      this.canvas.width = this.canvas.offsetWidth;
      const actualHeight = this.maxHeight || this.canvas.offsetHeight;
      this.canvas.height = actualHeight;
      this.numSquaresX = Math.ceil(this.canvas.width / this.squareSize) + 1;
      this.numSquaresY = Math.ceil(actualHeight / this.squareSize) + 1;
    }
    
    drawGrid() {
      if (!this.ctx) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      const startX = Math.floor(this.gridOffset.x / this.squareSize) * this.squareSize;
      const startY = Math.floor(this.gridOffset.y / this.squareSize) * this.squareSize;
      
      const maxDrawHeight = this.maxHeight || this.canvas.height;
      
      for (let x = startX; x < this.canvas.width + this.squareSize; x += this.squareSize) {
        for (let y = startY; y < maxDrawHeight + this.squareSize; y += this.squareSize) {
          const squareX = x - (this.gridOffset.x % this.squareSize);
          const squareY = y - (this.gridOffset.y % this.squareSize);
          
          if (
            this.hoveredSquare &&
            Math.floor((x - startX) / this.squareSize) === this.hoveredSquare.x &&
            Math.floor((y - startY) / this.squareSize) === this.hoveredSquare.y
          ) {
            this.ctx.fillStyle = this.hoverFillColor;
            this.ctx.fillRect(squareX, squareY, this.squareSize, this.squareSize);
          }
          
          this.ctx.strokeStyle = this.borderColor;
          this.ctx.strokeRect(squareX, squareY, this.squareSize, this.squareSize);
        }
      }
      
      // Add gradient overlay
      const gradient = this.ctx.createRadialGradient(
        this.canvas.width / 2,
        this.canvas.height / 2,
        0,
        this.canvas.width / 2,
        this.canvas.height / 2,
        Math.sqrt(this.canvas.width ** 2 + this.canvas.height ** 2) / 2
      );
      gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
      gradient.addColorStop(1, "rgba(6, 0, 16, 0.1)");
      
      this.ctx.fillStyle = gradient;
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    
    updateAnimation() {
      const effectiveSpeed = Math.max(this.speed, 0.1);
      switch (this.direction) {
        case "right":
          this.gridOffset.x = (this.gridOffset.x - effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "left":
          this.gridOffset.x = (this.gridOffset.x + effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "up":
          this.gridOffset.y = (this.gridOffset.y + effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "down":
          this.gridOffset.y = (this.gridOffset.y - effectiveSpeed + this.squareSize) % this.squareSize;
          break;
        case "diagonal":
          this.gridOffset.x = (this.gridOffset.x - effectiveSpeed + this.squareSize) % this.squareSize;
          this.gridOffset.y = (this.gridOffset.y - effectiveSpeed + this.squareSize) % this.squareSize;
          break;
      }
      
      this.drawGrid();
    }
    
    animate() {
      this.updateAnimation();
      this.requestRef = requestAnimationFrame(() => this.animate());
    }
    
    handleMouseMove(event) {
      const rect = this.canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      const startX = Math.floor(this.gridOffset.x / this.squareSize) * this.squareSize;
      const startY = Math.floor(this.gridOffset.y / this.squareSize) * this.squareSize;
      
      const hoveredSquareX = Math.floor((mouseX + this.gridOffset.x - startX) / this.squareSize);
      const hoveredSquareY = Math.floor((mouseY + this.gridOffset.y - startY) / this.squareSize);
      
      if (
        !this.hoveredSquare ||
        this.hoveredSquare.x !== hoveredSquareX ||
        this.hoveredSquare.y !== hoveredSquareY
      ) {
        this.hoveredSquare = { x: hoveredSquareX, y: hoveredSquareY };
      }
    }
    
    handleMouseLeave() {
      this.hoveredSquare = null;
    }
    
    destroy() {
      if (this.requestRef) {
        cancelAnimationFrame(this.requestRef);
      }
      if (this.resizeHandler) {
        window.removeEventListener('resize', this.resizeHandler);
      }
    }
  }
  
  let squaresInstance = null;

  // Initialize the squares background
  function initSquares() {
    // Cleanup existing instance
    if (squaresInstance) {
      squaresInstance.destroy();
      squaresInstance = null;
    }

    const canvas = document.getElementById('squares-canvas');
    if (canvas) {
      try {
        squaresInstance = new SquaresBackground(canvas);
      } catch (error) {
        console.error('Failed to initialize SquaresBackground:', error);
      }
    }
  }
  
  // Initialize on page load (including view transitions)
  document.addEventListener('astro:page-load', initSquares);
  
  // Cleanup on before swap
  document.addEventListener('astro:before-swap', () => {
    if (squaresInstance) {
      squaresInstance.destroy();
      squaresInstance = null;
    }
  });
</script>